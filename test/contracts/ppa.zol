// SPDX-License-Identifier: CC0

pragma solidity ^0.8.0;
contract SyntheticPpa {
    address public immutable owner;
    secret uint256 private strikePrice;
    secret uint256 private bundlePrice;
    secret uint256 private volumeShare;
    secret uint256 private dailyInterestRate;
    secret uint256 private startDateOfContract;
    secret uint256 private expiryDateOfContract;
    bool public isContractTerminated;

    secret mapping(uint256 => VolumeGap) private shortfalls;
    secret uint256 private latestShortfallSequenceNumber;

    secret mapping(uint256 => VolumeGap) private surpluses;
    secret uint256 private latestSurplusSequenceNumber;

    secret uint256 private sequenceNumberInterval;

    struct VolumeGap {
        uint256 billNumber;
        uint256 volume;
        uint256 price;
    }

    secret mapping(uint256 => uint256) private generatorCfdNetPosition;
    secret mapping(uint256 => uint256) private offtakerCfdNetPosition;
    secret mapping(uint256 => uint256) private generatorInterest;
    secret mapping(uint256 => uint256) private offtakerInterest;
    secret mapping(uint256 => uint256) private offtakerNegativePriceCharges;
    secret mapping(uint256 => uint256) private generatorNegativePriceCharges;

    secret uint256 private numberOfConsecutivePeriodsForShortfall;
    secret uint256 private shortfallThreshold;
    secret uint256 private shortfallPositiveChargeSum;
    secret uint256 private shortfallNegativeChargeSum;
    secret uint256 private shortfallIndex;
    secret mapping(uint256 => uint256) private shortfallPositiveCharges;
    secret mapping(uint256 => uint256) private shortfallNegativeCharges;

    secret uint256 private numberOfConsecutivePeriodsForSurplus;
    secret uint256 private surplusThreshold;
    secret uint256 private surplusPositiveChargeSum;
    secret uint256 private surplusNegativeChargeSum;
    secret uint256 private surplusIndex;
    secret mapping(uint256 => uint256) private surplusPositiveCharges;
    secret mapping(uint256 => uint256) private surplusNegativeCharges;

    modifier onlyOwner() {
        require(
            msg.sender == owner
        );
        _;
    }

    constructor() {
        owner = msg.sender;
    }


    function setStrikePrice(secret uint256 strikePriceParam) public onlyOwner {
        strikePrice = strikePriceParam;
    }

    function setBundlePrice(secret uint256 bundlePriceParam) public onlyOwner {
        bundlePrice = bundlePriceParam;
    }

    function setShortfallThreshold(secret uint256 shortfallThresholdParam) public onlyOwner {
        shortfallThreshold = shortfallThresholdParam;
    }

    function setShortfallPeriods(secret uint256 shortfallPeriods) public onlyOwner {
        numberOfConsecutivePeriodsForShortfall = shortfallPeriods;
    }

    function setSurplusThreshold(secret uint256 surplusThresholdParam) public onlyOwner {
        surplusThreshold = surplusThresholdParam;
    }

    function setSurplusPeriods(secret uint256 surplusPeriods) public onlyOwner {
        numberOfConsecutivePeriodsForSurplus = surplusPeriods;
    }

    function setDailyInterestRate(secret uint256 dailyInterestRateParam) public onlyOwner {
        dailyInterestRate = dailyInterestRateParam;
    }

    function setStartDateOfContract(secret uint256 startDateOfContractParam) public onlyOwner {
        startDateOfContract = startDateOfContractParam;
    }

    function setExpiryDateOfContract(secret uint256 expiryDateOfContractParam) public onlyOwner {
        expiryDateOfContract = expiryDateOfContractParam;
    }

    function setVolumeShare(secret uint256 volumeShareParam) public onlyOwner {
        volumeShare = volumeShareParam;
    }

    function setSequenceNumberInterval(secret uint256 sequenceNumberIntervalParam) public onlyOwner {
        sequenceNumberInterval = sequenceNumberIntervalParam;
    }

    function initSequenceNumber() public onlyOwner {
        latestShortfallSequenceNumber = 0;
        latestSurplusSequenceNumber = 0;
    }


    function setInitialContractParams(
        secret uint256 strikePriceParam,
        secret uint256 bundlePriceParam,
        secret uint256 volumeShareParam,
        secret uint256 numberOfConsecutivePeriodsForShortfallParam,
        secret uint256 shortfallThresholdParam,
        secret uint256 numberOfConsecutivePeriodsForSurplusParam,
        secret uint256 surplusThresholdParam,
        secret uint256 dailyInterestRateParam,
        secret uint256 startDateOfContractParam,
        secret uint256 expiryDateOfContractParam,
        secret uint256 sequenceNumberIntervalParam
    ) public onlyOwner {
        require(isContractTerminated == false);
        

        volumeShare = volumeShareParam;
        strikePrice = strikePriceParam;
        bundlePrice = bundlePriceParam;
        numberOfConsecutivePeriodsForShortfall = numberOfConsecutivePeriodsForShortfallParam;
        shortfallThreshold = shortfallThresholdParam;
        numberOfConsecutivePeriodsForSurplus = numberOfConsecutivePeriodsForSurplusParam;
        surplusThreshold = surplusThresholdParam;
        dailyInterestRate = dailyInterestRateParam;
        startDateOfContract = startDateOfContractParam;
        expiryDateOfContract = expiryDateOfContractParam;
        sequenceNumberInterval = sequenceNumberIntervalParam;
        latestShortfallSequenceNumber = 0;
        latestSurplusSequenceNumber = 0;
    }


    function calculateCfd(
        secret uint256 billNumber,
        secret uint256 sequenceNumber,
        secret uint256 totalGeneratedVolume,
        secret uint256 expectedVolume,
        secret uint256 averagePrice,
        secret uint256 marginalLossFactor,
        secret uint256 floatingAmount,
        secret uint256 positiveAdjustment,
        secret uint256 negativeAdjustment,
        secret uint256[5] calldata outstandingGeneratorAmount,
        secret uint256[5] calldata outstandingOfftakerAmount,
        secret uint256[5] calldata generatorDelayDays,
        secret uint256[5] calldata offtakerDelayDays,
        secret bool negativePriceOccurredParam,
        secret uint256 referenceDate
    ) public onlyOwner
      returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        
        require(referenceDate >= startDateOfContract);
        require(referenceDate <= expiryDateOfContract);
        require(!isContractTerminated);

        secret uint256 offtakerVolume = totalGeneratedVolume * volumeShare * marginalLossFactor;
        secret uint256 fixedAmount = 0;
        if(bundlePrice <= 0) {
            fixedAmount = offtakerVolume * strikePrice; 
        } else {
            fixedAmount = offtakerVolume * bundlePrice;
        }

        secret uint256 netPositiveAdjustment = 0;
        secret uint256 netNegativeAdjustment = 0;
        if(negativeAdjustment > positiveAdjustment) {
            netNegativeAdjustment = negativeAdjustment - positiveAdjustment;
        } else {
            netPositiveAdjustment = positiveAdjustment - negativeAdjustment;
        }

        // Positive adjustment means that the price has been retroactively increased;
        // therefore, it's a debt for the offtaker to the generator.
        // Since a higher fixed amount is also a debt for the offtaker to the generator,
        // positive adjustment and fixed amount can be added together.
        // Negative adjustment works the same with the floating amount.
        // The logic and calculations below need to sacrifice readability in order to
        // avoid nested ifs, brackets and negative numbers.

        if ((floatingAmount + netNegativeAdjustment) > (fixedAmount + netPositiveAdjustment)) {
            generatorCfdNetPosition[billNumber] = floatingAmount + netNegativeAdjustment - fixedAmount - netPositiveAdjustment;
        } else {
            offtakerCfdNetPosition[billNumber] = fixedAmount + netPositiveAdjustment - floatingAmount - netNegativeAdjustment;
        }

        secret uint256 shortfallSequence = 0;
        if(sequenceNumber == latestShortfallSequenceNumber + sequenceNumberInterval ||
            latestShortfallSequenceNumber == 0 ||
            sequenceNumber == 0
        ) {
            shortfallSequence = 1;
        }

        secret uint256 surplusSequence = 0;
        if(sequenceNumber == latestSurplusSequenceNumber + sequenceNumberInterval ||
            latestSurplusSequenceNumber == 0 ||
            sequenceNumber == 0
        ) {
            surplusSequence = 1;
        }
        
        secret uint256 positivePriceDifference = 0;
        secret uint256 negativePriceDifference = 0;
        if(averagePrice > strikePrice) {
            positivePriceDifference = averagePrice - strikePrice;
        } else {
            negativePriceDifference = strikePrice - averagePrice;
        }

        // Shortfall and surplus difference
        secret uint256 volumeDifference = 0;
        if(expectedVolume > offtakerVolume) {   
            volumeDifference = expectedVolume - offtakerVolume;
        } else {
            volumeDifference = offtakerVolume - expectedVolume;
        }

        if(negativePriceOccurredParam && expectedVolume > offtakerVolume) {   
            generatorNegativePriceCharges[billNumber] = volumeDifference * strikePrice;
        } 
        
        if (negativePriceOccurredParam && expectedVolume <= offtakerVolume) {
            offtakerNegativePriceCharges[billNumber] = volumeDifference * strikePrice;
        }

        // Shortfall calculation
        secret uint256 index = shortfallIndex + 0;
        if (shortfallSequence != 0 && expectedVolume > offtakerVolume && volumeDifference >= shortfallThreshold && numberOfConsecutivePeriodsForShortfall > 0) {
            shortfalls[index].billNumber = billNumber;
            shortfalls[index].price = averagePrice;
            shortfalls[index].volume = volumeDifference;
            shortfallPositiveChargeSum += shortfalls[index].volume * positivePriceDifference;
            shortfallNegativeChargeSum += shortfalls[index].volume * negativePriceDifference;
            shortfallIndex += 1;
            latestShortfallSequenceNumber = sequenceNumber;
        } 

        if (shortfallSequence != 0 && (expectedVolume <= offtakerVolume || volumeDifference < shortfallThreshold)) {
            shortfallPositiveChargeSum = 0;
            shortfallNegativeChargeSum = 0;
            shortfallIndex = 0;
            latestShortfallSequenceNumber = 0;
        }

        if (shortfallIndex >= numberOfConsecutivePeriodsForShortfall && numberOfConsecutivePeriodsForShortfall > 0 ) {
            shortfallPositiveCharges[billNumber] = shortfallPositiveChargeSum;
            shortfallNegativeCharges[billNumber] = shortfallNegativeChargeSum;
            shortfallPositiveChargeSum = 0;
            shortfallNegativeChargeSum = 0;
            shortfallIndex = 0;
            latestShortfallSequenceNumber = 0;
        }

        // Surplus calculation
        index = surplusIndex + 0;
        if (surplusSequence != 0 && expectedVolume < offtakerVolume && volumeDifference >= surplusThreshold && numberOfConsecutivePeriodsForSurplus > 0) {
            surpluses[index].billNumber = billNumber;
            surpluses[index].price = averagePrice;
            surpluses[index].volume = volumeDifference;
            surplusPositiveChargeSum += surpluses[index].volume * positivePriceDifference;
            surplusNegativeChargeSum += surpluses[index].volume * negativePriceDifference;
            surplusIndex += 1;
            latestSurplusSequenceNumber = sequenceNumber;
        }

        if (surplusSequence != 0 && (expectedVolume >= offtakerVolume || volumeDifference < surplusThreshold)) {
            surplusPositiveChargeSum = 0;
            surplusNegativeChargeSum = 0;
            surplusIndex = 0;
            latestSurplusSequenceNumber = 0;
        }

        if (surplusIndex >= numberOfConsecutivePeriodsForSurplus && numberOfConsecutivePeriodsForSurplus > 0) {
            surplusPositiveCharges[billNumber] = surplusPositiveChargeSum;
            surplusNegativeCharges[billNumber] = surplusNegativeChargeSum;
            surplusPositiveChargeSum = 0;
            surplusNegativeChargeSum = 0;
            surplusIndex = 0;
            latestSurplusSequenceNumber = 0;
        }

        for (uint256 i = 0; i < 5; i++) {
            if (outstandingGeneratorAmount[i] > 0) {
                generatorInterest[billNumber] += outstandingGeneratorAmount[i] * generatorDelayDays[i] * dailyInterestRate;
            } if (outstandingOfftakerAmount[i] > 0) {
                offtakerInterest[billNumber] += outstandingOfftakerAmount[i] * offtakerDelayDays[i] * dailyInterestRate;
            }
        }

        return (
            generatorCfdNetPosition[billNumber],
            offtakerCfdNetPosition[billNumber],
            generatorInterest[billNumber],
            offtakerInterest[billNumber],
            shortfallPositiveCharges[billNumber],
            shortfallNegativeCharges[billNumber],
            surplusPositiveCharges[billNumber],
            surplusNegativeCharges[billNumber],
            generatorNegativePriceCharges[billNumber],
            offtakerNegativePriceCharges[billNumber]
        );
    }

    
    function terminateContract()  public onlyOwner {
        isContractTerminated = true;
    }
}